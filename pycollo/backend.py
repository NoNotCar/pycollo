"""

Attributes
----------
CASADI : str
    Constant keyword string identifier for the Pycollo-CasADi backend.
PYCOLLO : str
    Constant keyword string identifier for the Pycollo-only (hSAD) backend.
SYMPY : str
    Constant keyword string identifier for the Pycollo-Sympy backend.
BACKENDS : :py:class:`Options <pyproprop>`
    The default backend to be used (via its constant keyword string
    identifier).

"""


import itertools
from abc import ABC, abstractmethod
from collections import namedtuple

import casadi as ca
import numpy as np
import sympy as sym
from pyproprop import Options, processed_property

from .bounds import Bounds
from .compiled import CompiledFunctions
from .expression_graph import ExpressionGraph
from .guess import Guess
from .iteration import Iteration
from .mesh import Mesh
from .quadrature import Quadrature
from .scaling import Scaling
from .utils import (console_out, dict_merge, fast_sympify,
                    format_multiple_items_for_output, sympy_to_casadi)


__all__ = []


CASADI = "casadi"
HSAD = "hsad"
PYCOLLO = "pycollo"
SYMPY = "sympy"


class BackendABC(ABC):
    """Abstract base class for backends"""

    ocp = processed_property("ocp", read_only=True)

    def __init__(self, ocp):
        self.ocp = ocp
        self.create_aux_data_containers()
        self.create_point_variable_symbols()
        self.create_phase_backends()
        self.preprocess_user_problem_aux_data()
        self.preprocess_phase_backends()
        self.collect_variables_substitutions()
        self.console_out_variables_constraints_preprocessed()

    @staticmethod
    @abstractmethod
    def sym(name):
        pass

    def create_aux_data_containers(self):
        """Instantiate containers for mapping symbols to expressions.

        Two types of container are made: :attr:`user_to_backend_mapping` holds
        a mapping from user-defined symbols to the corresponding symbols
        automatically-generated by the backend; and :attr:`aux_data` holds a
        mapping from the backend symbols to the backend equations defining the
        symbol in question.

        """
        self.user_to_backend_mapping = {}
        self.aux_data = {}

    def create_point_variable_symbols(self):
        """Abstraction layer for creating problem-level variable symbols."""
        self.create_parameter_variable_symbols()

    def create_parameter_variable_symbols(self):
        """Create static parameter variables symbols and associated data.

        The user supplies symbols to the OCP that are unscaled (as these
        symbols crop up in the OCP equations etc.). Pycollo automatically
        handles problem scaling by introducing a scaling for every variable
        when introduced. This is done by shifting and stretching that
        variable's domain on to the window [-0.5, 0.5] (which is handled by the
        :mod:`scaling` module within Pycollo). The Pycollo backend deals with
        the scaled version of the symbols, or the "tilde" symbols. The scaled
        symbols are moved to the original domain first by stretching them by
        the "stretch" factor `V`, then by shifting them by the "shift" factor
        `r`. To move from the scaled (tilde) variable to the unscaled
        (user-defined) variable the following transformation is used:

        ..math::
            x = V * x_tilde + r

        """
        self.num_s_vars_full = len(self.ocp._s_vars_user)
        s = (self.sym(f"_s{i_s}") for i_s in range(self.num_s_vars_full))
        self.create_parameter_variable_scaling_symbols()
        self.s_vars_full = tuple(s)
        s_vars_subs_mappings = self.create_variable_scaling_substitution(
            self.ocp._s_vars_user, self.s_vars_full, self.V_s_vars_full,
            self.r_s_vars_full)
        self.s_vars_user = self.ocp._s_vars_user

    def add_user_to_backend_mapping(self):
        pass

    def add_aux_data_mapping(self, backend_sym, backend_expr):
        self.aux_data.update(dict(zip(backend_sym, backend_expr)))

    def create_parameter_variable_scaling_symbols(self):
        V_s = (self.sym(f"_V_s{i_s}") for i_s in range(self.num_s_vars_full))
        r_s = (self.sym(f"_r_s{i_s}") for i_s in range(self.num_s_vars_full))
        self.V_s_vars_full = tuple(V_s)
        self.r_s_vars_full = tuple(r_s)

    @staticmethod
    def create_variable_scaling_substitution(xs_user, xs, Vs, rs):
        return {x_user: V * x + r
                for x_user, x, V, r in zip(xs_user, xs, Vs, rs)}

    def create_phase_backends(self):
        p = (PycolloPhaseData(self, phase) for phase in self.ocp.phases)
        self.p = tuple(p)
        self.num_phases = len(self.p)
        self.all_phase_vars = {var for p in self.p for var in p.all_user_vars}
        self.all_vars = self.all_phase_vars.union(set(self.s_vars_user))

    def preprocess_user_problem_aux_data(self):
        self.user_phase_aux_data_syms = {symbol
                                         for phase in self.ocp.phases
                                         for symbol in phase.auxiliary_data}
        self.user_aux_data_mapping = {}
        self.aux_data_phase_dependent = {}
        self.aux_data_phase_independent = {}
        self.aux_data_supplied_in_ocp_and_phase = {}
        self.add_problem_variable_scalings_aux_data()
        for symbol, equation in self.ocp.auxiliary_data.items():
            self.partition_user_problem_phase_aux_data(symbol, equation)
        self.check_user_phase_aux_data_not_user_problem_aux_data()
        self.partition_user_problem_aux_data()

    def add_problem_variable_scalings_aux_data(self):
        """Abstraction layer for problem/phase variable scaling expressions."""
        self.add_problem_point_variable_scalings_aux_data()
        for p in self.p:
            p.add_phase_variable_scalings_aux_data()

    def add_problem_point_variable_scalings_aux_data(self):
        """Add auxiliary scaling expressions for parameter variables."""
        components_zip = zip(self.s_vars_user,
                             self.s_vars_full,
                             self.V_s_vars_full,
                             self.r_s_vars_full)
        for s_user, s, V, r in components_zip:
            self.aux_data.update({s_user: V * s + r})

    @abstractmethod
    def partition_user_problem_phase_aux_data(self, symbol, equation):
        """
        Determine category of user-supplied aux data.

        Each item of user-supplied auxiliary data can fall in to one of three
        categories: generic aux data, aux data supplied simultaneously at the
        problem and phase level, and phase-dependent aux data. This function
        determines which category each key-value aux data pair falls in to so
        that it can be processed appropriately by other methods.

        """
        pass

    @abstractmethod
    def check_user_phase_aux_data_not_user_problem_aux_data(self):
        """Alert user of any problem- and phase-level aux data definitions.

        Aux data can only be supplied at either the problem-level or the
        phase-level. If a user has supplied an auxiliary equation mapped to an
        auxiliary symbol in both the :class:`OptimalControlProblem` object and
        a :class:`Phase` object then a `ValueError` should be raised.

        """
        pass

    @abstractmethod
    def partition_user_problem_aux_data(self):
        pass

    def preprocess_phase_backends(self):
        for p in self.p:
            p.preprocess_auxiliary_data()
            p.preprocess_constraints()
            p.create_constraint_indexes_slices()

    def collect_variables_substitutions(self):
        self.all_subs_mappings = dict_merge(self.s_vars_subs_mappings,
                                            *[p.all_subs_mappings for p in self.p])
        self.aux_data = {phase_sym: user_eqn.xreplace(self.all_subs_mappings)
                         for phase_sym, user_eqn in self.aux_data_phase_independent.items()}

    def console_out_variables_constraints_preprocessed(self):
        if self.ocp.settings.console_out_progress:
            msg = "Pycollo variables and constraints preprocessed."
            console_out(msg)

    def create_bounds(self):
        self.bounds = Bounds(self)
        self.recollect_variables_and_slices()

    def create_compiled_functions(self):
        self.compiled_functions = CompiledFunctions(self)

    def create_guess(self):
        phase_guesses = [p.ocp_phase.guess for p in self.p]
        endpoint_guess = self.ocp.guess
        self.initial_guess = Guess(self, phase_guesses, endpoint_guess)

    def create_initial_mesh(self):
        phase_meshes = [p.ocp_phase.mesh for p in self.p]
        self.initial_mesh = Mesh(self, phase_meshes)

    def create_mesh_iterations(self):
        self.mesh_iterations = []
        _ = self.new_mesh_iteration(self.initial_mesh, self.initial_guess)

    def create_quadrature(self):
        self.quadrature = Quadrature(self)

    def create_scaling(self):
        self.scaling = Scaling(self)

    def new_mesh_iteration(self, mesh, guess):
        index = len(self.mesh_iterations)
        new_iteration = Iteration(
            backend=self,
            index=index,
            mesh=mesh,
            guess=guess,
        )
        self.mesh_iterations.append(new_iteration)
        return new_iteration


class PycolloPhaseData:

    def __init__(self, ocp_backend, ocp_phase):

        self.ocp_backend = ocp_backend
        self.ocp_phase = ocp_phase
        self.i = ocp_phase.phase_number
        self.create_variable_symbols()
        self.preprocess_variables()
        self.create_full_variable_indexes_slices()

    def sym(self, *args, **kwargs):
        """Handoff method for symbol creation.

        Symbol creation is handled by the OCP backend so phase backends pass
        these requests off to their :py:attr:`ocp_backend`.

        """
        return self.ocp_backend.sym(*args, **kwargs)

    def create_variable_symbols(self):
        """Abstraction layer converning creation of all phase OCP variables."""
        self.create_state_variable_symbols()
        self.create_control_variable_symbols()
        self.create_integral_variable_symbols()
        self.create_time_variable_symbols()
        self.create_variable_scaling_symbols()

    def create_state_variable_symbols(self):
        """Instantiate phase state variables (including enpoint symbols)."""
        self.num_y_vars_full = len(self.ocp_phase._y_vars_user)
        self.y_vars_full = tuple(self.sym(f"_y{i_y}_P{self.i}")
                                 for i_y in range(self.num_y_vars_full))
        self.y_t0_vars_full = tuple(self.sym(f"{y}_t0")
                                    for y in self.y_vars_full)
        self.y_tF_vars_full = tuple(self.sym(f"{y}_tF")
                                    for y in self.y_vars_full)
        y_point_vars_zip = zip(self.y_t0_vars_full, self.y_tF_vars_full)
        self.y_point_vars_full = tuple(
            itertools.chain.from_iterable(y for y in y_point_vars_zip))
        self.num_y_point_vars_full = len(self.y_point_vars_full)

    def create_control_variable_symbols(self):
        """Instantiate phase control variable symbols."""
        self.num_u_vars_full = len(self.ocp_phase._u_vars_user)
        self.u_vars_full = tuple(self.sym(f'_u{i_u}_P{self.i}')
                                 for i_u in range(self.num_u_vars_full))
        self.num_u_vars_full = len(self.u_vars_full)

    def create_integral_variable_symbols(self):
        """Instantiate phase integral variable symbols."""
        self.num_q_vars_full = len(self.ocp_phase._q_vars_user)
        self.q_vars_full = tuple(self.sym(f"_{q}")
                                 for q in self.ocp_phase._q_vars_user)

    def create_time_variable_symbols(self):
        """Instantiate phase time variable symbols."""
        self.num_t_vars_full = 2
        self.t_vars_full = (self.sym(str(self.ocp_phase._t0)),
                            self.sym(str(self.ocp_phase._tF)))
        self.t_norm = self.ocp_phase._STRETCH

    def create_variable_scaling_symbols(self):
        """Abstraction layer for creating scaling symbols for all vars."""
        for x_identifier in ("y", "u", "q"):
            self.create_specific_variable_scaling_symbols(x_identifier)

    def create_specific_variable_scaling_symbols(self, x_identifier):
        """Create scaling (stretch and shift) variables."""
        num_x = getattr(self, f"num_{x_identifier}_vars_full")
        V_s = (self.sym(f"_V_{x_identifier}{i_x}_P{self.i}")
               for i_x in range(num_x))
        r_s = (self.sym(f"_r_{x_identifier}{i_x}_P{self.i}")
               for i_x in range(num_x))
        setattr(self, f"V_{x_identifier}_vars_full", tuple(V_s))
        setattr(self, f"r_{x_identifier}_vars_full", tuple(r_s))

    def preprocess_variables(self):
        """Abstraction layer for preprocessing of Pycollo/user variables."""
        self.collect_pycollo_variables_full()
        self.collect_user_variables()

    def collect_pycollo_variables_full(self):
        """Collect Pycollo variables and associated data."""
        x_vars_full = itertools.chain(self.y_vars_full,
                                      self.u_vars_full,
                                      self.q_vars_full,
                                      self.t_vars_full)
        self.x_vars_full = tuple(x_vars_full)
        self.num_vars_full = len(self.x_vars_full)
        self.num_each_vars_full = (self.num_y_vars_full,
                                   self.num_u_vars_full,
                                   self.num_q_vars_full,
                                   self.num_t_vars_full)
        x_point_vars_full = itertools.chain(self.y_point_vars_full,
                                            self.q_vars_full,
                                            self.t_vars_full)
        self.x_point_vars_full = tuple(x_point_vars_full)
        self.num_point_vars_full = len(self.x_point_vars_full)

    def collect_user_variables(self):
        """Collect user variables and associated data."""
        self.y_vars_user = self.ocp_phase._y_vars_user
        self.y_t0_vars_user = self.ocp_phase._y_t0_user
        self.y_tF_vars_user = self.ocp_phase._y_tF_user
        y_zip = zip(self.y_t0_vars_user, self.y_tF_vars_user)
        y_point_vars_user = itertools.chain.from_iterable(y for y in y_zip)
        self.y_point_vars_user = tuple(y_point_vars_user)
        self.u_vars_user = self.ocp_phase._u_vars_user
        self.q_vars_user = self.ocp_phase._q_vars_user
        self.t_vars_user = self.ocp_phase._t_vars_user
        x_vars_user = itertools.chain(self.y_vars_user,
                                      self.u_vars_user,
                                      self.q_vars_user,
                                      self.t_vars_user)
        self.x_vars_user = tuple(x_vars_user)
        x_point_vars_user = itertools.chain(self.y_point_vars_user,
                                            self.q_vars_user,
                                            self.t_vars_user)
        self.x_point_vars_user = tuple(x_point_vars_user)
        self.all_user_vars = set(self.x_vars_user + self.x_point_vars_user)

    def create_full_variable_indexes_slices(self):
        """Abstraction layer for preprocessing of Pycollo/user slices."""
        self.create_full_continuous_variable_indexes_slices()
        self.create_full_point_variable_indexes_slices()

    def create_full_continuous_variable_indexes_slices(self):
        """Create slices and indices for the continuous Pycollo variables."""
        y_start = 0
        u_start = y_start + self.num_y_vars_full
        q_start = u_start + self.num_u_vars_full
        t_start = q_start + self.num_q_vars_full
        x_end = self.num_vars_full
        self.y_slice_full = slice(y_start, u_start)
        self.u_slice_full = slice(u_start, q_start)
        self.q_slice_full = slice(q_start, t_start)
        self.t_slice_full = slice(t_start, x_end)
        self.yu_slice_full = slice(y_start, q_start)
        self.qt_slice_full = slice(q_start, x_end)
        self.yu_qt_split_full = q_start

    def create_full_point_variable_indexes_slices(self):
        """Create slices and indices for the endpoint Pycollo variables."""
        y_point_start = 0
        q_point_start = y_point_start + self.num_y_point_vars_full
        t_point_start = q_point_start + self.num_q_vars_full
        x_point_end = self.num_point_vars_full
        self.y_point_full_slice = slice(y_point_start, q_point_start)
        self.q_point_full_slice = slice(q_point_start, t_point_start)
        self.t_point_full_slice = slice(t_point_start, x_point_end)
        self.qt_point_full_slice = slice(q_point_start, x_point_end)
        self.y_point_qt_point_full_split = q_point_start

    def add_phase_variable_scalings_aux_data(self):
        """Add auxiliary scaling expressions to aux data for phase vars.

        No time-based scaling needs to happen as handled manually and the use
        of the time symbol `t` as an independent variable in OCP formulations
        is not currently supported.

        """
        y_scaling_aux_data = self.get_phase_variable_scaling_aux_data(
            self.y_vars_user,
            self.y_vars_full,
            self.V_y_vars_full,
            self.r_y_vars_full)
        self.ocp_backend.aux_data.update(y_scaling_aux_data)
        u_scaling_aux_data = self.get_phase_variable_scaling_aux_data(
            self.u_vars_user,
            self.u_vars_full,
            self.V_u_vars_full,
            self.r_u_vars_full)
        self.ocp_backend.aux_data.update(u_scaling_aux_data)
        q_scaling_aux_data = self.get_phase_variable_scaling_aux_data(
            self.q_vars_user,
            self.q_vars_full,
            self.V_q_vars_full,
            self.r_q_vars_full)
        self.ocp_backend.aux_data.update(q_scaling_aux_data)
        y_t0_scaling_aux_data = self.get_phase_variable_scaling_aux_data(
            self.y_t0_vars_user,
            self.y_t0_vars_full,
            self.V_y_vars_full,
            self.r_y_vars_full)
        self.ocp_backend.aux_data.update(y_t0_scaling_aux_data)
        y_tF_scaling_aux_data = self.get_phase_variable_scaling_aux_data(
            self.y_tF_vars_user,
            self.y_tF_vars_full,
            self.V_y_vars_full,
            self.r_y_vars_full)
        self.ocp_backend.aux_data.update(y_tF_scaling_aux_data)

    @staticmethod
    def get_phase_variable_scaling_aux_data(xs_user, xs, Vs, rs):
        zipped = zip(xs_user, xs, Vs, rs)
        return {x_user: V * x + r for x_user, x, V, r in zipped}

    def preprocess_auxiliary_data(self):
        """Abstraction layer for preprocessing of user-supplied aux data."""
        self.create_auxiliary_variables_for_user_phase_aux_data()
        self.check_all_user_phase_aux_data_supplied()
        self.collect_variables_substitutions()

    def create_auxiliary_variables_for_user_phase_aux_data(self):
        self.aux_data = {}
        self.user_phase_aux_data_mapping = {}
        per_phase_aux_data = dict_merge(self.ocp_phase.auxiliary_data,
                                        self.ocp_backend.aux_data_phase_dependent)
        for user_sym, user_eqn in per_phase_aux_data.items():
            phase_sym = sym.Symbol(f"_p_{user_sym}_P{self.i}")
            self.aux_data[phase_sym] = fast_sympify(user_eqn)
            self.user_phase_aux_data_mapping[user_sym] = phase_sym

    def check_all_user_phase_aux_data_supplied(self):
        self_aux_user_keys = set(self.user_phase_aux_data_mapping.keys())
        missing_syms = self.ocp_backend.user_phase_aux_data_syms.difference(
            self_aux_user_keys)
        self.missing_user_phase_aux_data_syms = missing_syms

    def collect_variables_substitutions(self):
        vars_subs = dict(zip(self.x_vars_user, self.x_vars_full))
        point_vars_subs = dict(
            zip(self.x_point_vars_user, self.x_point_vars_full))
        self.all_subs_mappings = dict_merge(vars_subs, point_vars_subs,
                                            self.user_phase_aux_data_mapping,
                                            self.ocp_backend.s_vars_subs_mappings)
        self.aux_data = {phase_sym: user_eqn.xreplace(self.all_subs_mappings)
                         for phase_sym, user_eqn in self.aux_data.items()}

    def preprocess_constraints(self):
        self.preprocess_defect_constraints()
        self.preprocess_path_constraints()
        self.preprocess_integral_constraints()
        self.collect_constraints()
        self.check_all_needed_user_phase_aux_data_supplied()

    def preprocess_defect_constraints(self):
        self.zeta = tuple(y_eqn.xreplace(self.all_subs_mappings)
                          for y_eqn in self.ocp_phase.state_equations)
        self.num_c_defect = self.ocp_phase.number_state_equations

    def preprocess_path_constraints(self):
        self.gamma = tuple(p_con.xreplace(self.all_subs_mappings)
                           for p_con in self.ocp_phase.path_constraints)
        self.num_c_path = self.ocp_phase.number_path_constraints

    def preprocess_integral_constraints(self):
        self.rho = tuple(q_fnc.xreplace(self.all_subs_mappings)
                         for q_fnc in self.ocp_phase.integrand_functions)
        self.num_c_integral = self.ocp_phase.number_integrand_functions

    def collect_constraints(self):
        self.c = (self.zeta + self.gamma + self.rho)
        self.num_c = (self.num_c_defect +
                      self.num_c_path + self.num_c_integral)

    def create_constraint_indexes_slices(self):
        self.c_defect_slice = slice(0, self.num_c_defect)
        self.c_path_slice = slice(self.c_defect_slice.stop,
                                  self.c_defect_slice.stop + self.num_c_path)
        self.c_integral_slice = slice(self.c_path_slice.stop, self.num_c)

    def check_all_needed_user_phase_aux_data_supplied(self):
        needed_syms = {s for c in self.c for s in c.free_symbols}
        missing_syms = needed_syms.intersection(
            self.missing_user_phase_aux_data_syms)
        if missing_syms:
            self.raise_needed_user_phases_aux_data_missing_error(missing_syms)

    def raise_needed_user_phases_aux_data_missing_error(self, missing_syms):
        formatted_syms = format_multiple_items_for_output(missing_syms)
        msg = (f"Phase-dependent auxiliary data must be supplied for "
                f"all phase-dependent symbols in each phase. Please supply "
                f"auxiliary data for {formatted_syms} in {self.ocp_phase.name} "
                f"(phase index: {self.i}).")
        raise ValueError(msg)

    def collect_pycollo_variables(self):
        self.y_vars = tuple(np.array(self.y_vars_full)[
                            self.ocp_phase.bounds._y_needed].tolist())
        self.u_vars = tuple(np.array(self.u_vars_full)[
                            self.ocp_phase.bounds._u_needed].tolist())
        self.q_vars = tuple(np.array(self.q_vars_full)[
                            self.ocp_phase.bounds._q_needed].tolist())
        self.t_vars = tuple(np.array(self.t_vars_full)[
                            self.ocp_phase.bounds._t_needed].tolist())
        self.x_vars = self.y_vars + self.u_vars + self.q_vars + self.t_vars

        self.num_y_vars = len(self.y_vars)
        self.num_u_vars = len(self.u_vars)
        self.num_q_vars = len(self.q_vars)
        self.num_t_vars = len(self.t_vars)
        self.num_vars = len(self.x_vars)

        self.y_t0_vars = tuple(np.array(self.y_t0_vars_full)[
                               self.ocp_phase.bounds._y_needed].tolist())
        self.y_tF_vars = tuple(np.array(self.y_tF_vars_full)[
                               self.ocp_phase.bounds._y_needed].tolist())
        self.y_point_vars = tuple(itertools.chain.from_iterable(y
                                                                for y in zip(self.y_t0_vars, self.y_tF_vars)))
        self.num_y_point_vars = len(self.y_point_vars)

        self.num_each_vars = (self.num_y_vars, self.num_u_vars,
                              self.num_q_vars, self.num_t_vars)
        self.x_point_vars = (self.y_point_vars + self.q_vars
                             + self.t_vars)
        self.num_point_vars = len(self.x_point_vars)

        self.create_variable_indexes_slices()

    def create_variable_indexes_slices(self):
        self.create_continuous_variable_indexes_slices()
        self.create_point_variable_indexes_slices()

    def create_continuous_variable_indexes_slices(self):
        self.y_slice = slice(0, self.num_y_vars)
        self.u_slice = slice(self.y_slice.stop,
                             self.y_slice.stop + self.num_u_vars)
        self.q_slice = slice(self.u_slice.stop,
                             self.u_slice.stop + self.num_q_vars)
        self.t_slice = slice(self.q_slice.stop, self.num_vars)
        self.yu_slice = slice(self.y_slice.start,
                              self.u_slice.stop)
        self.qt_slice = slice(self.q_slice.start, self.num_vars)
        self.yu_qt_split = self.yu_slice.stop

    def create_point_variable_indexes_slices(self):
        self.y_point_slice = slice(0, self.num_y_point_vars)
        self.q_point_slice = slice(self.y_point_slice.stop,
                                   self.y_point_slice.stop + self.num_q_vars)
        self.t_point_slice = slice(self.q_point_slice.stop,
                                   self.num_point_vars)
        self.qt_point_slice = slice(self.q_point_slice.start,
                                    self.num_point_vars)
        self.y_point_qt_point_split = self.y_point_slice.stop


class Pycollo(BackendABC):

    def __init__(self, ocp):
        super().__init__(ocp)
        self.create_expression_graph()

    @staticmethod
    def syms(name, rows=1, cols=1):
        if (rows == 1) and (cols == 1):
            return sym.Symbol(name)
        raise NotImplementedError

    def create_expression_graph(self):
        variables = self.collect_variables()
        objective = None
        constraints = None
        aux_data = self.collect_aux_data()
        self.expression_graph_full = ExpressionGraph(self, variables, objective,
                                                     constraints, aux_data)

    def collect_variables(self):
        continuous_vars_full = (tuple(itertools.chain.from_iterable(p.x_vars_full
                                                                    for p in self.p)) + self.s_vars_full)
        self.num_vars_full = len(continuous_vars_full)
        endpoint_vars_full = (tuple(itertools.chain.from_iterable(p.x_point_vars_full
                                                                  for p in self.p)) + self.s_vars_full)
        variables = (continuous_vars_full, endpoint_vars_full)
        self.phase_variable_full_slices = []
        start = 0
        for p in self.p:
            stop = start + p.num_vars_full
            p_slice = slice(start, stop)
            start = stop
            self.phase_variable_full_slices.append(p_slice)
        return variables

    def collect_aux_data(self):
        aux_data = dict_merge(self.aux_data, *(p.aux_data for p in self.p))
        return aux_data

    def recollect_variables_and_slices(self):
        self.recollect_variables()
        self.process_objective_function()
        self.process_point_constraints()
        self.build_expression_graph()

    def recollect_variables(self):
        for p in self.p:
            p.collect_pycollo_variables()

        self.s_vars = tuple(np.array(self.s_vars_full)[
                            self.ocp.bounds._s_needed].tolist())
        self.num_s_vars = len(self.s_vars)

        continuous_vars = (tuple(itertools.chain.from_iterable(p.x_vars
                                                               for p in self.p)) + self.s_vars)
        self.x_vars = continuous_vars
        self.num_vars = len(continuous_vars)
        endpoint_vars = (tuple(itertools.chain.from_iterable(p.x_point_vars
                                                             for p in self.p)) + self.s_vars)
        self.x_point_vars = endpoint_vars
        self.num_point_vars = len(endpoint_vars)
        self.variables = (continuous_vars, endpoint_vars)

        self.phase_y_vars_slices = []
        self.phase_u_vars_slices = []
        self.phase_q_vars_slices = []
        self.phase_t_vars_slices = []
        self.phase_variable_slices = []
        phase_start = 0
        for p in self.p:
            start = phase_start
            stop = start + p.num_y_vars
            p_slice = slice(start, stop)
            self.phase_y_vars_slices.append(p_slice)
            start = stop
            stop = start + p.num_u_vars
            p_slice = slice(start, stop)
            self.phase_u_vars_slices.append(p_slice)
            start = stop
            stop = start + p.num_q_vars
            p_slice = slice(start, stop)
            self.phase_q_vars_slices.append(p_slice)
            start = stop
            stop = start + p.num_t_vars
            p_slice = slice(start, stop)
            self.phase_t_vars_slices.append(p_slice)
            start = stop
            phase_stop = phase_start + p.num_vars
            p_slice = slice(phase_start, phase_stop)
            self.phase_variable_slices.append(p_slice)
            phase_start = phase_stop
        self.s_vars_slice = slice(
            self.num_vars - self.num_s_vars, self.num_vars)
        self.variable_slice = self.s_vars_slice

        self.phase_endpoint_variable_slices = []
        start = 0
        for p in self.p:
            stop = start + p.num_point_vars
            p_slice = slice(start, stop)
            start = stop
            self.phase_endpoint_variable_slices.append(p_slice)
        self.endpoint_variable_slice = slice(
            self.num_point_vars - self.num_s_vars, self.num_point_vars)

    def process_objective_function(self):
        self.J = self.ocp.objective_function.xreplace(self.all_subs_mappings)

    def process_point_constraints(self):
        all_y_vars = []
        all_y_t0_vars = []
        all_y_tF_vars = []
        for p in self.p:
            all_y_vars.extend(list(p.y_vars))
            all_y_t0_vars.extend(list(p.y_t0_vars))
            all_y_tF_vars.extend(list(p.y_tF_vars))
        all_y_vars_set = set(all_y_vars)
        all_y_bnds = []
        for var, x_bnds in zip(self.x_vars, self.bounds.x_bnds):
            if var in all_y_vars_set:
                all_y_bnds.append(x_bnds)
        endpoint_state_constraints = []
        endpoint_state_constraints_bounds = []
        for y_t0_var, y_tF_var, y_bnds, y_t0_bnds, y_tF_bnds in zip(
                all_y_t0_vars, all_y_tF_vars, all_y_bnds, self.bounds.y_t0_bnds, self.bounds.y_tF_bnds):
            if np.any(~np.isclose(np.array(y_t0_bnds), np.array(y_bnds))):
                endpoint_state_constraints.append(y_t0_var)
                endpoint_state_constraints_bounds.append(y_t0_bnds)
            if np.any(~np.isclose(np.array(y_tF_bnds), np.array(y_bnds))):
                endpoint_state_constraints.append(y_tF_var)
                endpoint_state_constraints_bounds.append(y_tF_bnds)
        self.y_beta = tuple(endpoint_state_constraints)
        self.bounds.c_y_bnds = endpoint_state_constraints_bounds
        self.beta = tuple(b_con.xreplace(self.all_subs_mappings)
                          for b_con in self.ocp.endpoint_constraints)
        self.num_c_endpoint = self.ocp.number_endpoint_constraints

    def collect_constraints(self):
        constraints = (tuple(itertools.chain.from_iterable(p.c
                                                           for p in self.p)) + self.beta)

        self.num_c = len(constraints)
        self.phase_defect_constraint_slices = []
        self.phase_path_constraint_slices = []
        self.phase_integral_constraint_slices = []
        self.phase_constraint_slices = []
        phase_start = 0
        for p in self.p:
            start = phase_start
            stop = start + p.num_c_defect
            p_slice = slice(start, stop)
            self.phase_defect_constraint_slices.append(p_slice)
            start = stop
            stop = start + p.num_c_path
            p_slice = slice(start, stop)
            self.phase_path_constraint_slices.append(p_slice)
            start = stop
            stop = start + p.num_c_integral
            p_slice = slice(start, stop)
            self.phase_integral_constraint_slices.append(p_slice)
            start = stop
            phase_stop = phase_start + p.num_c
            p_slice = slice(phase_start, phase_stop)
            self.phase_constraint_slices.append(p_slice)
            phase_start = phase_stop

        start = 0
        stop = self.phase_constraint_slices[-1].stop
        self.c_continuous_slice = slice(start, stop)
        start = stop
        stop = start + self.num_c_endpoint
        self.c_endpoint_slice = slice(start, stop)
        return constraints

    def build_expression_graph(self):
        variables = self.variables
        objective = self.J
        constraints = self.collect_constraints()
        aux_data = dict_merge(self.aux_data, *(p.aux_data for p in self.p), self.bounds.aux_data)
        self.expression_graph = ExpressionGraph(self, variables, objective,
                                                constraints, aux_data)
        self.expression_graph.form_functions_and_derivatives()


class Casadi(BackendABC):

    @staticmethod
    def sym(name, rows=1, cols=1):
        return ca.SX.sym(name, rows, cols)

    @staticmethod
    def const(val):
        return ca.DM(val)

    @staticmethod
    def get_primitives(eqn):
        if isinstance(eqn, ca.DM):
            return set()
        return ca.symvar(eqn)

    def partition_user_problem_phase_aux_data(self, user_sym, user_eqn):
        """

        ```python
        equation = fast_sympify(equation)
        if symbol in self.user_phase_aux_data_syms:
            self.aux_data_supplied_in_ocp_and_phase[symbol] = equation
        elif self.user_phase_aux_data_syms.intersection(equation.free_symbols):
            self.aux_data_phase_dependent[symbol] = equation
        else:
            self.aux_data[symbol] = equation
        ```

        """
        if user_sym in self.user_aux_data_mapping:
            backend_sym = self.user_aux_data_mapping[user_sym]
        else:
            backend_sym = self.sym(str(user_sym))
            self.user_aux_data_mapping[user_sym] = backend_sym
        if isinstance(user_eqn, sym.Expr):
            backend_eqn, self.user_aux_data_mapping = sympy_to_casadi(
                user_eqn, self.user_aux_data_mapping)
        else:
            backend_eqn = self.const(user_eqn)
        eqn_prims = self.get_primitives(backend_eqn)
        if user_sym in self.user_phase_aux_data_syms:
            self.aux_data_supplied_in_ocp_and_phase[user_sym] = backend_eqn
        elif self.user_phase_aux_data_syms.intersection(eqn_prims):
            self.aux_data_phase_dependent[user_sym] = backend_eqn
        else:
            self.aux_data[user_sym] = backend_eqn

    def check_user_phase_aux_data_not_user_problem_aux_data(self):
        """

        ```python
        if self.aux_data_supplied_in_ocp_and_phase:
            formatted_syms = format_multiple_items_for_output(
                self.aux_data_supplied_in_ocp_and_phase)
            msg = (f"Auxiliary data for {formatted_syms} has been supplied at "
                    f"a per-phase level and therefore cannot be supplied at a "
                    f"problem level.")
            raise ValueError(msg)
        ```

        """
        pass

    def partition_user_problem_aux_data(self):
        pass


class Hsad(BackendABC):

    not_implemented_error_msg = ("The hSAD backend for Pycollo is not "
                                 "currently supported or implemented.")

    def __init__(self, ocp):
        raise NotImplementedError(self.not_implemented_error_msg)

    @classmethod
    def sym(cls, name):
        raise NotImplementedError(cls.not_implemented_error_msg)

    def partition_user_problem_phase_aux_data(self, symbol, equation):
        equation = fast_sympify(equation)
        if symbol in self.user_phase_aux_data_syms:
            self.aux_data_supplied_in_ocp_and_phase[symbol] = equation
        elif self.user_phase_aux_data_syms.intersection(equation.free_symbols):
            self.aux_data_phase_dependent[symbol] = equation
        else:
            self.aux_data[symbol] = equation

    def check_user_phase_aux_data_not_user_problem_aux_data(self):
        if self.aux_data_supplied_in_ocp_and_phase:
            formatted_syms = format_multiple_items_for_output(
                self.aux_data_supplied_in_ocp_and_phase)
            msg = (f"Auxiliary data for {formatted_syms} has been supplied at "
                    f"a per-phase level and therefore cannot be supplied at a "
                    f"problem level.")
            raise ValueError(msg)

    def partition_user_problem_aux_data(self):
        for symbol, equation in self.aux_data.items():
            self.process_aux_data_pair_is_phase_dependent(symbol, equation)

    def process_aux_data_pair_is_phase_dependent(self, symbol, equation):
        if symbol in self.aux_data_phase_dependent:
            return True
        elif equation in self.all_phase_vars:
            self.new_aux_data_pair_phase_independent(symbol, equation)
            return True
        elif equation in self.s_vars_user:
            return False
        elif equation.is_Number:
            self.new_aux_data_pair_phase_independent(symbol, equation)
            return False
        else:
            return self.check_aux_data_pair_children(symbol, equation)

    def new_aux_data_pair_phase_dependent(self, symbol, equation):
        self.aux_data_phase_dependent[symbol] = equation

    def new_aux_data_pair_phase_independent(self, symbol, equation):
        self.aux_data_phase_independent[symbol] = equation

    def check_aux_data_pair_children(self, symbol, equation):
        child_syms = list(equation.free_symbols)
        child_eqns = [self.get_child_equation(child_sym)
                      for child_sym in child_syms]
        child_is_phase_dependent = [
            self.process_aux_data_pair_is_phase_dependent(child_sym, child_eqn)
            for child_sym, child_eqn in zip(child_syms, child_eqns)]
        if any(child_is_phase_dependent):
            self.new_aux_data_pair_phase_dependent(symbol, equation)
            return True
        else:
            self.new_aux_data_pair_phase_independent(symbol, equation)
            return False

    def get_child_equation(self, symbol):
        all_symbol_equation_mappings = dict_merge(self.aux_data,
                                                  self.aux_data_phase_dependent, self.aux_data_phase_independent)
        equation = all_symbol_equation_mappings.get(symbol)
        if symbol in self.all_vars:
            return symbol
        elif equation is None:
            msg = (f"'{symbol}' is not defined.")
            raise ValueError(msg)
        return equation


class Sympy(BackendABC):

    not_implemented_error_msg = ("The Sympy backend for Pycollo is not "
                                 "currently supported or implemented.")

    def __init__(self, ocp):
        raise NotImplementedError(self.not_implemented_error_msg)

    @staticmethod
    def sym(name):
        raise NotImplementedError(not_implemented_error_msg)

    def partition_user_problem_phase_aux_data(self, symbol, equation):
        raise NotImplementedError(not_implemented_error_msg)

    def check_user_phase_aux_data_not_user_problem_aux_data(self):
        raise NotImplementedError(not_implemented_error_msg)

    def partition_user_problem_aux_data(self):
        raise NotImplementedError(not_implemented_error_msg)


BACKENDS = Options((PYCOLLO, HSAD, CASADI, SYMPY), default=CASADI,
                   unsupported=(PYCOLLO, HSAD, SYMPY),
                   handles=(Pycollo, Hsad, Casadi, Sympy))
